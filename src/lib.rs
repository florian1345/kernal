#![allow(clippy::wrong_self_convention)]

use std::fmt::Debug;

pub mod abs_diff;
pub mod boolean;
pub mod character;
pub mod collections;
pub mod error;
pub mod lock;
pub mod num;
pub mod option;
pub mod panic;
pub mod partial_eq;
pub mod partial_ord;
pub mod pointer;
pub mod string;

#[cfg(test)]
pub(crate) mod test_util;

pub mod prelude;

/// This struct holds the evaluated result of an expression for further assertions. It also contains
/// metadata used for generating helpful error messages should an assertion fail.
///
/// The main mode of interaction with this struct is by assertions defined by various `*Assertions`
/// traits. To import all of them and get access to all kinds of assertions, glob-import the
/// [prelude] module.
pub struct AssertThat<T> {
    pub(crate) data: T,
    pub(crate) expression: String
}

impl<T> AssertThat<T> {

    #[doc(hidden)]
    #[must_use]
    pub fn new(data: T, expression: String) -> AssertThat<T> {
        AssertThat {
            data,
            expression
        }
    }
}

/// This macro starts every assertion. It takes an expression and returns an [AssertThat] instance
/// which allows to perform various assertions on the value generated by the expression. Remember to
/// import [prelude] in order to get access to all assertions. That import also provides this macro.
///
/// As an example, consider the valid assertion below.
///
/// ```
/// use kernal::prelude::*;
///
/// assert_that!(1 + 1).is_equal_to(2);
/// ```
#[macro_export]
macro_rules! assert_that {
    ($expression:expr) => {
        $crate::AssertThat::new($expression, stringify!($expression).to_owned())
    };
}

/// This type is used to generate error messages of a specific format. It is mostly used internally,
/// but exported to enable users to extend the assertions provided by this crate for custom types.
pub struct Failure {
    expression: String,
    expected_it: Option<String>,
    but_it: Option<String>
}

impl Failure {

    /// Creates a new failure that takes the possible information from the [AssertThat] on whose
    /// data the failed assertion is run.
    #[must_use]
    pub fn new<T>(assert_that: &AssertThat<T>) -> Failure {
        Failure::from_expression(&assert_that.expression)
    }

    /// Creates a new failure for an assertion on a value that was obtained by evaluating the given
    /// `expression`. This should ideally represent the actual Rust code.
    #[must_use]
    pub fn from_expression(expression: impl Into<String>) -> Failure {
        Failure {
            expression: expression.into(),
            expected_it: None,
            but_it: None
        }
    }

    /// Specifies the string to display in the error message to represent the expectation.
    /// Grammatically, it should follow the words "expected it".
    #[must_use]
    pub fn expected_it(mut self, expected_it: impl Into<String>) -> Failure {
        self.expected_it = Some(expected_it.into());
        self
    }

    /// Specifies the string to display in the error message to represent the actual value and
    /// failure. Grammatically, it should follow the words "but it" after the phrase generated by
    /// [Failure::expected_it].
    #[must_use]
    pub fn but_it(mut self, but_it: impl Into<String>) -> Failure {
        self.but_it = Some(but_it.into());
        self
    }

    /// Shorthand for [Failure::but_it] where the message is "was ..." with "..." being set to the
    /// [Debug] formatting of the data tested by the given `assert_that`.
    #[must_use]
    pub fn but_it_was_data<T: Debug>(self, assert_that: &AssertThat<T>) -> Failure {
        self.but_it(format!("was <{:?}>", &assert_that.data))
    }

    /// Panics with a failure message composed by arguments of previous method calls on this
    /// failure, such as [Failure::expected_it] and [Failure::but_it]
    pub fn fail(&self) -> ! {
        panic!("{}", self.message());
    }

    fn message(&self) -> String {
        let expected_it = self.expected_it.as_ref()
            .expect("incomplete failure: no expected_it provided");
        let but_it = self.but_it.as_ref()
            .expect("incomplete failure: no but_it provided");

        format!("expected: <{}> {}\nbut:      it {}", &self.expression, expected_it, but_it)
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn assert_that_contains_correct_data() {
        assert_eq!(assert_that!(0).data, 0);
    }
    
    #[test]
    fn assert_that_contains_correct_expression() {
        assert_eq!(&assert_that!(1 + (2 * 3)).expression, "1 + (2 * 3)");
    }

    #[test]
    #[should_panic(expected = "expected: <a> b\nbut:      it c")]
    fn failure_panics_with_correct_message() {
        let assert_that = AssertThat {
            data: 0,
            expression: "a".to_owned()
        };

        Failure::new(&assert_that)
            .expected_it("b")
            .but_it("c")
            .fail();
    }
}
